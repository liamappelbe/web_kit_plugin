import Flutter
import Foundation
import UIKit
import WebKit

public class WebKitPlugin: NSObject, FlutterPlugin {
  public static func register(with registrar: FlutterPluginRegistrar) {
    let factory = WebKitViewFactory(messenger: registrar.messenger())
    registrar.register(factory, withId: "plugins.flutter.io/swift_webview")
  }
}

class WebKitViewFactory: NSObject, FlutterPlatformViewFactory {
  private var messenger: FlutterBinaryMessenger

  init(messenger: FlutterBinaryMessenger) {
    self.messenger = messenger
    super.init()
  }

  func create(
    withFrame frame: CGRect,
    viewIdentifier viewId: Int64,
    arguments args: Any?
  ) -> FlutterPlatformView {
    return WebKitNativeView(id: args as! Int64)
  }

  public func createArgsCodec() -> FlutterMessageCodec & NSObjectProtocol {
    return FlutterStandardMessageCodec.sharedInstance()
  }
}

class WebKitNativeView: NSObject, FlutterPlatformView {
  private var _webView: WebKitViewWrapper

  init(id: Int64) {
    // The WebKitViewWrapper is passed from Dart to Swift through the
    // WebKitViewFactory as an int, then we cast it to a WebView.
    _webView = WebKitViewWrapper.intToObject!(id) as! WebKitViewWrapper
    super.init()
  }

  func view() -> UIView {
    return _webView.view()
  }
}

class WeakRef<T: NSObject> {
  weak var value: T?
  init(value: T) {
    self.value = value
  }
}

// StrongRef is used to force the wrapped object to stay alive until drop() is
// called. This allows us to pass NSObjects over async callbacks to Dart code
// that may run an arbitrary time later. The Dart callback should call drop().
// Swift is a refcounted language, so the StrongRef is kept alive by holding a
// cyclic reference to itself.
//
// ObjC doesn't support generics, so usually we would codegen a specialized
// wrapper for each T needed. But for StrongRef that won't quite work because
// the wrapper itself needs to be kept alive. So instead the specializations
// below duplicate this logic. We'll need to special case StrongRef in the
// codegen tool.
class StrongRef<T: NSObject> {
  let value: T
  private var keepAlive: StrongRef<T>?

  init(value: T) {
    self.value = value
    keepAlive = self
  }

  func drop() {
    keepAlive = nil
  }
}

// =============================================================================
// Most code below this point should be auto-generated by upcoming tools. But I
// haven't been super strict about only writing generatable code below here. In
// particular, NavigationDelegateWrapper and WebKitViewWrapper contain some hand
// written logic. If we were actually using codegen, that logic should be split
// out into its own classes. They would be an additional layer of wrappers in
// between the native Swift objects and the codegen'd ObjC compatibility layer.
// =============================================================================

@objc class NavigationDelegateWrapper : NSObject, WKNavigationDelegate {
  // SwiftNagivationDelegate.onNavigationRequest
  @objc var decidePolicyForNavigationAction:
      ((NavigationActionWrapper, _: Closure_Void_Int) -> Void)?
  func webView(
      _ webView: WKWebView,
      decidePolicyFor navigationAction: WKNavigationAction,
      decisionHandler: @escaping (WKNavigationActionPolicy) -> Void) {
    // Using handlerWrapper to manage object lifetimes, rather than StrongRef.
    var navigationWrapper: NavigationActionWrapper? =
        NavigationActionWrapper(action: navigationAction)
    var handlerWrapper: Closure_Void_Int? = nil
    handlerWrapper = Closure_Void_Int(closure: { (policy: Int) -> Void in
      decisionHandler(WKNavigationActionPolicy(rawValue: policy)!)
      handlerWrapper = nil
      navigationWrapper = nil
    })
    decidePolicyForNavigationAction?(navigationWrapper!, handlerWrapper!)
  }

  // SwiftNavigationDelegate.onPageStarted
  @objc var didStartProvisionalNavigation: ((StrongRef_NSURL?) -> Void)?
  func webView(
      _ webView: WKWebView,
      didStartProvisionalNavigation navigation: WKNavigation!) {
    let url = webView.url
    didStartProvisionalNavigation?(
        url == nil ? nil : StrongRef_NSURL(value: url! as NSURL))
  }

  // SwiftNavigationDelegate.onPageFinished
  @objc var didFinishNavigation: ((StrongRef_NSURL?) -> Void)?
  func webView(_ webView: WKWebView, didFinish navigation: WKNavigation!) {
    let url = webView.url
    didFinishNavigation?(url == nil ? nil : StrongRef_NSURL(value: url! as NSURL))
  }

  // SwiftNavigationDelegate.onWebResourceError
  @objc var didFailNavigation: ((StrongRef_NSError, StrongRef_NSURL?) -> Void)?
  func webView(
      _ webView: WKWebView, didFail navigation: WKNavigation!,
      withError error: any Error) {
    let url = webView.url
    didFailNavigation?(
        StrongRef_NSError(value: error as NSError),
        url == nil ? nil : StrongRef_NSURL(value: url! as NSURL))
  }

  // SwiftNavigationDelegate.onWebResourceError
  @objc var didFailProvisionalNavigation: ((StrongRef_NSError, StrongRef_NSURL?) -> Void)?
  func webView(
      _ webView: WKWebView,
      didFailProvisionalNavigation navigation: WKNavigation!,
      withError error: any Error) {
    let url = webView.url
    didFailProvisionalNavigation?(
        StrongRef_NSError(value: error as NSError),
        url == nil ? nil : StrongRef_NSURL(value: url! as NSURL))
  }

  // SwiftNavigationDelegate.onWebResourceError
  @objc var webContentProcessDidTerminate: (() -> Void)?
  func webViewWebContentProcessDidTerminate(_ webView: WKWebView) {
    webContentProcessDidTerminate?()
  }
}

@objc class WebKitViewWrapper : NSObject {
  @objc static var intToObject: ((Int64) -> NSObject)?

  private var _webView: WKWebView

  @objc override init() {
    let webConfiguration = WKWebViewConfiguration()
    _webView = WKWebView(frame: .zero, configuration: webConfiguration)

    super.init()

    _webView.addObserver(
      self,
      forKeyPath: "estimatedProgress",
      options: [NSKeyValueObservingOptions.new],
      context: nil)
    _webView.addObserver(
      self,
      forKeyPath: "URL",
      options: [NSKeyValueObservingOptions.new],
      context: nil)
  }

  deinit {
    _webView.removeObserver(self, forKeyPath: "estimatedProgress")
    _webView.removeObserver(self, forKeyPath: "URL")
  }

  // SwiftNavigationDelegate.onProgress
  @objc var onProgress: ((Double) -> Void)?
  // SwiftNavigationDelegate.onUrlChange
  @objc var onUrlChange: ((StrongRef_NSURL?) -> Void)?
  override func observeValue(
    forKeyPath keyPath: String?,
    of object: Any?,
    change: [NSKeyValueChangeKey : Any]?,
    context: UnsafeMutableRawPointer?
  ) {
    if (keyPath == "estimatedProgress") {
      onProgress?(change![NSKeyValueChangeKey.newKey]! as! Double);
    } else if (keyPath == "URL") {
      let url = change![NSKeyValueChangeKey.newKey] as! NSURL?
      onUrlChange?(url == nil ? nil : StrongRef_NSURL(value: url! as NSURL));
    }
  }

  func view() -> UIView {
    return _webView
  }

  @objc func load(request: URLRequest) {
    _webView.load(request)
  }

  @objc func setBackgroundColor(
      red: CGFloat, green: CGFloat, blue: CGFloat, alpha: CGFloat) {
    _webView.backgroundColor = UIColor(
        red: red, green: green, blue: blue, alpha: alpha)
  }

  @objc func setJavaScriptEnabled(enabled: Bool) {
    _webView.configuration.preferences.javaScriptEnabled = enabled
  }

  @objc func setNavigationDelegate(delegate: NavigationDelegateWrapper) {
    _webView.navigationDelegate = delegate
  }
}

@objc class NavigationActionWrapper : NSObject {
  private let _action: WKNavigationAction

  @objc init(action: WKNavigationAction) {
    _action = action
    super.init()
  }

  @objc var request: URLRequest {
    get {
      return _action.request
    }
  }

  @objc var targetFrame: FrameInfoWrapper? {
    get {
      let info: WKFrameInfo? = _action.targetFrame
      return info == nil ? nil : FrameInfoWrapper(info: info!)
    }
  }
}

@objc class FrameInfoWrapper : NSObject {
  private let _info: WKFrameInfo

  @objc init(info: WKFrameInfo) {
    _info = info
    super.init()
  }

  @objc var isMainFrame: Bool {
    get {
      return _info.isMainFrame
    }
  }
}

// ObjC closures (blocks) are callable from Swift, but the converse is not true.
// To call a Swift closure from ObjC we wrap it in an @objc compatible wrapper.
@objc class Closure_Void_Int : NSObject {
  private var _closure: (Int) -> Void

  init(closure: @escaping (Int) -> Void) {
    _closure = closure
    super.init()
  }

  @objc func call(arg: Int) {
    return _closure(arg)
  }
}

@objc class StrongRef_NSURL : NSObject {
  @objc let value: NSURL
  private var keepAlive: StrongRef_NSURL?

  init(value: NSURL) {
    self.value = value
    super.init()
    keepAlive = self
  }

  @objc func drop() {
    keepAlive = nil
  }
}

@objc class StrongRef_NSError : NSObject {
  @objc let value: NSError
  private var keepAlive: StrongRef_NSError?

  init(value: NSError) {
    self.value = value
    super.init()
    keepAlive = self
  }

  @objc func drop() {
    keepAlive = nil
  }
}
